#pragma config(Sensor, S3,     WallSensor,     sensorTouch)
#pragma config(Sensor, S4,     SpinSensor,     sensorSONAR)
#pragma config(Motor,  motorA,          SensorMotor,   tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          WheelL,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          WheelR,        tmotorNXT, PIDControl, encoder)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//global vairables
bool WallCenter;
bool WallLeft;
bool WallRight;


//initialisation of Array that holds total wall measurment
int WallDistancePointer = 0;
int WallDistanceNodePos[100];

//vector array of wall measurments
class WallDistance
{
//the fact this is public is not very good
public:
	int DistanceArray[100];  //create an array to record the wall distances in a set class
	bool IsWall;
};

void DynamicArrayCreation ()
{
////this is just test code
int *WallPointer; //Declare pointer to type of array
 //using 3 array instead of 1 one dimmentional arrays because it saves a lot more memory
WallDistance[3] = 10;          //Use as normal (static) array
delete [] WallDistance;       //remeber to free memeory when finished.

//simple vairable array size using copy over
//http://www.cplusplus.com/forum/beginner/1601/
}

//array enlargment runs in oredr to expand array size
void ArrayEnlargment ()
{
	//WallDistance Array is expanded by 50 slots
	int DistanceArrayTempStore[WallDistancePointer];
	int DistanceArrayTempCounter = 0;

	//center version
	while (DistanceArrayTempCounter != WallDistancePointer)
	{
		DistanceArrayTempCounter[DistanceArrayTempCounter] = Center.DistanceArray[WallDistancePointer];
		DistanceArrayTempCounter++;
	}
	//deletes the old array! this is expermental
	delete [] Center.DistanceArray;
	Center.DistanceArray = new int [DistancePointer + 50];
	//deletes the copy over to save memory
	DistanceArrayTempCounter = 0;
	while (DistanceArrayTempCounter != DistancePointer)
	{
		Center.Array[DistanceTempCounter] = DistanceArrayTempStore[DistanceArrayTempStore];
		DistanceArrayTempCounter++;
	}

	//resets the counter for the next version
	DistanceArrayTempCounter = 0;
	//Left version
	while (DistanceArrayTempCounter != WallDistancePointer)
	{
		DistanceArrayTempCounter[DistanceArrayTempCounter] = Left.DistanceArray[WallDistancePointer];
		DistanceArrayTempCounter++;
	}
	//deletes the old array! this is expermental
	delete [] Left.DistanceArray;
	Left.DistanceArray = new int [DistancePointer + 50];
	//deletes the copy over to save memory
	DistanceArrayTempCounter = 0;
	while (DistanceArrayTempCounter != DistancePointer)
	{
		Left.Array[DistanceTempCounter] = DistanceArrayTempStore[DistanceArrayTempStore];
		DistanceArrayTempCounter++;
	}

	//resets the counter for the next version
	DistanceArrayTempCounter = 0;
	//Right version
	while (DistanceArrayTempCounter != WallDistancePointer)
	{
		DistanceArrayTempCounter[DistanceArrayTempCounter] = Right.DistanceArray[WallDistancePointer];
		DistanceArrayTempCounter++;
	}
	//deletes the old array! this is expermental
	delete [] Right.DistanceArray;
	Right.DistanceArray = new int [DistancePointer + 50];
	//deletes the copy over to save memory
	DistanceArrayTempCounter = 0;
	while (DistanceArrayTempCounter != DistancePointer)
	{
		Right.Array[DistanceTempCounter] = DistanceArrayTempStore[DistanceArrayTempStore];
		DistanceArrayTempCounter++;
	}

	//resets the counter for the next version
	DistanceArrayTempCounter = 0;
	//Node Expansion version
	while (DistanceArrayTempCounter != WallDistancePointer)
	{
		DistanceArrayTempCounter[DistanceArrayTempCounter] = WallDistanceNodePos[WallDistancePointer];
		DistanceArrayTempCounter++;
	}
	//deletes the old array! this is expermental
	delete [] WallDistanceNodePos;
	WallDistanceNodePos = new int [DistancePointer + 50];
	//deletes the copy over to save memory
	DistanceArrayTempCounter = 0;
	while (DistanceArrayTempCounter != DistancePointer)
	{
		WallDistanceNodePos[DistanceTempCounter] = DistanceArrayTempStore[DistanceArrayTempStore];
		DistanceArrayTempCounter++;
	}

	//saves stack memory space
	delete [] DistanceTempCounter;
	delete [] DistanceArrayTempStore;
}

//tree traversal initialisation
//place start node
Node* root; //Root node pointer
root = NULL; //global root struct of 3 options

//master conflict
//tree traversal initialisation https://www.youtube.com/watch?v=COZK7NATh4k
//13.50

struct Node
{
	int data;
	//was struct Node
	struct Node* left;
	struct Node* right;
}
//
Node* GetNewNode(int data)
{
	Node* newNode = new Node();
	(*newNode).data = data;
	newNode.left = newNode.right = NULL;
	return newNode;
}

Node* Insert(Node* root,int data) //was a void before
{
	if(root == NULL)
	{
		root = GetNewNode(data);
		return root;
	}
	else if(data <= root.data)
	{
		root.left = Insert(root.left,data);
	}
	return root;
}

bool Search(Node* root, int data)
{
	if(root == NULL)
	{
	//empty Tree
	return false;
	}
	else if(root.data == data)
	{
	return true;
	}
	else if(data <= root.data)
	{
	return Search(root.left,data);
} else {
	Search(root.right,data);
}

}

//data search function in basic void to AVOID errors
void TreeEntry()
{
	//basic empty tree code Because semantics //Node* root = NULL;
	root = Insert(root,15);
	root = Insert(root,10);
	root = Insert(root,20);

	root = Insert(root,25);
	root = Insert(root,8);
	root = Insert(root,12);

	int number;
	cout<<"number to search";
	cin>>number;
	//this bit is not correct but the node struct should work nicely BOYYS
	if(Search(root,number) == tree) cout<<"Found";
	else cout<<"Not Found";
}

//dynamic global int structure using the vector structure
int size;
std::cin >> size;
int *WallArray = new int [size];


//predefined movements

void ReverseFromWall()
{
		//too close script
		motor[WheelL] = -25;
		motor[WheelR] = -25;
		wait1Msec(500);
		motor[WheelL] = 0;
		motor[WheelR] = 0;
		//recursive backup loop
		SensorWallCenter();
}

//foward while until 10 away

void CenterTurn()
{
	while(SensorValue(SpinSensor) > 10){
		motor[WheelL] = 25;
		motor[WheelR] = 25;
		if (SensorValue(WallSensor) == 1)
		{
			SensorWallCenter();
			break;
		}
	}
		motor[WheelL] = 0;
		motor[WheelR] = 0;
}
//Turn right preset movement
void RightTurn()
{
	motor[WheelL] = -20;
	motor[WheelR] = 20;
	wait1Msec(1000);
	motor[WheelL] = 0;
	motor[WheelR] = 0;
}

//Turn left preset movement
void LeftTurn()
{
	motor[WheelL] = 20;
	motor[WheelR] = -20;
	wait1Msec(1000);
	motor[WheelL] = 0;
	motor[WheelR] = 0;
}

void SensorWallCenter()
{
	if(SensorValue(SpinSensor) < 15){
		playTone(764, 15);
		Center.IsWall = true;
	} else {
	//wall not here
	Center.IsWall = false;
	}
	Center.DistanceArray[WallDistancePointer] = SensorValue(SpinSensor);
}

void SensorWallLeft()
{
	//moves sensor left
	motor[SensorMotor] = 12;
	wait1Msec(1000);
	//recenters the motor
	motor[SensorMotor] = 0;
	wait1Msec(500);
	//takes reading
	if(SensorValue(SpinSensor) < 15){
		playTone(764, 15);
		Left.IsWall = true;
	} else {
		Left.IsWall = false;
	}

	//Records the Sensor value in the array before it is moved back
	Left.DistanceArray[WallDistancePointer] = SensorValue(SpinSensor);
	//
	//moves sensor right
	motor[SensorMotor] = -12;
	wait1Msec(1000);
	//recenters the motor
	motor[SensorMotor] = 0;
	wait1Msec(500);
}

void SensorWallRight()
{
	//moves sensor right
	motor[SensorMotor] = -12;
	wait1Msec(1000);
	//recenters the motor
	motor[SensorMotor] = 0;
	wait1Msec(500);
	//takes reading
	//
	if(SensorValue(SpinSensor) < 15){
		playTone(764, 15);
		Right.IsWall = true;
	} else {
		Right.IsWall = false;
	}
	//Records the Sensor value in the array before it is moved back
	Right.DistanceArray[WallDistancePointer] = SensorValue(SpinSensor);

	//moves sensor left
	motor[SensorMotor] = 12;
	wait1Msec(1000);
	//recenters the motor
	motor[SensorMotor] = 0;
	wait1Msec(500);
}

//current stupid work around because c++ is dumb
//look to get work around with bool functions
//
bool EndReached = false;

void TurnAround()
{
	//360 turn script
	//int turnvair = SensorValue(SpinSensor);
	motor[WheelL] = -25;
	motor[WheelR] = 25;
	wait1Msec(2000);
	motor[WheelL] = 0;
	motor[WheelR] = 0;

}

void WallSearch()
{
	SensorWallCenter();
	SensorWallRight();
	SensorWallLeft();
	//logging sensor Data
	WallDistancePointer++; //iterates the position in each array

	if (Center.IsWall == false )
	{
		//no wall in front
		CenterTurn();
	}else if (Left.IsWall == false){
		LeftTurn();
	}else if (Right.IsWall == false){
		RightTurn();
	}else if (Center.IsWall == true && Left.IsWall == true && Right.IsWall == true){
		//DeadEnd Script
		playTone(764, 15);
		playTone(764, 15);
		TurnAround();
	}
}



//main start
task main()
{


WallDistance Right, Left, Center; //class declaration

//place start node

while(EndReached == false)
{

	WallSearch();

	//Check For Bool Change
	if (SensorValue(WallSensor) == 1)
	{
		ReverseFromWall();
	}
}

while(EndReached == true)
{
	//run search for start using tree traversal
	//reverse the tree search
}

}
